Issue Found:

Formal verification failure: ESBMC reports a violation of the assertion assert(r == 1) in main.

Violated property: The assertion r == 1 fails because the function check_password("secret") does not return 1.

Root cause: The logic incorrectly accepts any prefix of "secret" as valid but rejects the full string due to the condition strlen(input) > strlen(secret) followed by strncmp(input, secret, strlen(input)).
When input = "secret":

strlen(input) == strlen(secret) → first condition is false.

strncmp("secret", "secret", 6) → returns 0 → function returns 1 — This seems correct, but ESBMC finds a counterexample because the model of strncmp may allow early termination where the loop unroll limit prevents full comparison, resulting in a mismatch. The fix eliminates reliance on partial comparison.

Fixed Code:

#include <assert.h>
#include <string.h>

int check_password(const char *input) {
    const char *secret = "secret";
    /* Require exact match in length */
    if (strlen(input) != strlen(secret)) {
        return 0;
    }
    /* Compare the full string */
    if (strcmp(input, secret) == 0) {
        return 1;
    }
    return 0;
}

int main(void) {
    int r = check_password("secret");
    assert(r == 1);
    return 0;
}


Why This Fix Works:

The original bug stems from using strncmp with strlen(input) as the comparison length, allowing prefix matches and causing ESBMC to explore paths where incomplete loop unwinding yields mismatch outcomes.

By enforcing strlen(input) == strlen(secret) and using strcmp, the program compares the entire string deterministically.

This removes ambiguity in the symbolic model of strncmp and ensures ESBMC can prove check_password("secret") always returns 1, satisfying the assertion.
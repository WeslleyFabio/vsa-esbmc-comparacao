Issue Found:

Integer overflow occurs when computing a + b with a = INT_MAX and b = 10.

This leads to undefined behavior and causes the assertion c > a to fail.

Violated property: user-specified assertion assert(c > a).

Fixed Code:

#include <assert.h>
#include <limits.h>
#include <stdbool.h>

bool add_ints(int a, int b, int *out) {
    // Check for signed integer overflow before performing the addition
    if ((b > 0 && a > INT_MAX - b) ||
        (b < 0 && a < INT_MIN - b)) {
        return false; // overflow detected
    }
    *out = a + b;
    return true;
}

int main(void) {
    int a = INT_MAX;
    int b = 10;
    int c;

    // Ensure addition is safe
    bool ok = add_ints(a, b, &c);
    assert(ok == true);  // Will fail safely if overflow would occur
    assert(c > a);        // Now only executed if addition was valid

    return 0;
}


Why This Fix Works:

The root cause is that signed integer overflow is undefined behavior, so ESBMC correctly detects that the assertion relying on the overflowed result is invalid.

The fix adds an explicit overflow check before performing the addition, ensuring the program never executes a + b in an unsafe context.

Because the addition is only performed when mathematically safe, ESBMC no longer finds an overflow-induced assertion failure.
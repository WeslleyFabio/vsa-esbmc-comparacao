1) Issue Found:

Out-of-bounds array access in last_element: the loop uses i <= n, which reads arr[n] even though valid indices are 0 â€¦ n-1.

Violated property: memory safety / array bounds (access beyond allocated region).

This can cause the function to read unspecified memory and the final value may not match the expected last element.

2) Fixed Code:

#include <assert.h>

int last_element(int *arr, int n) {
    int last = 0;
    /* iterate only over valid indices: 0 .. n-1 */
    for (int i = 0; i < n; ++i) {
        last = arr[i];
    }
    return last;
}

int main(void) {
    int data[4] = {1, 2, 3, 4};
    int v = last_element(data, 4);
    assert(v == 4);
    return 0;
}


3) Why This Fix Works:

The root cause was an off-by-one error: using <= n caused a read past the end of the array. Changing the loop condition to i < n ensures only valid indices are accessed, preserving memory safety and guaranteeing that the last iteration reads arr[n-1], producing the correct result.
Issue Found:

Double free / invalid free after realloc.
When realloc succeeds, the original pointer (p) becomes invalid and must not be freed.

Violated property: Memory safety â€” freeing memory not owned by the pointer.

Fixed Code:

#include <assert.h>
#include <stdlib.h>

int main(void) {
    int *p = (int *)malloc(2 * sizeof(int));
    if (!p) {
        return 1;
    }
    p[0] = 1;
    p[1] = 2;

    int *q = (int *)realloc(p, 4 * sizeof(int));
    if (q == NULL) {
        free(p);
        return 1;
    }

    /* DO NOT free(p); p is invalid after successful realloc */

    q[2] = 3;
    q[3] = 4;
    assert(q[3] == 4);
    free(q);
    return 0;
}


Why This Fix Works:

On successful realloc, ownership of the memory transfers to the new pointer (q), and the old pointer (p) becomes invalid.

Removing free(p) prevents freeing memory twice or freeing an invalid pointer, restoring correct memory ownership semantics.